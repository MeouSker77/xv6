\chapter{自陷和系统调用}\label{ch04}

有三种事件会导致CPU暂停执行普通的指令，并强行跳转到处理这个事件的特殊代码处。
一种情况是系统调用，用户程序执行\texttt{ecall}指令要求内核为它提供服务。
另一种情况是\emph{异常(exception)}：一条指令（用户程序或内核中的）做了一些非法的事情，例如除以0或者使用了无效的虚拟地址。
第三种情况是设备\emph{中断(interrupt)}：一个设备可能会发送信号表示它需要关注，例如磁盘硬件完成了一个读或写请求。

这本书使用\emph{自陷(trap)}作为这三种情况的通用术语。
通常情况下，不管自陷时在执行什么代码，之后都需要恢复，并且这段代码不应该意识到这期间发生了别的事情。
也就是说，我们希望自陷是透明的，这对硬件中断来说尤其重要，被中断的代码通常不期望这些中断。
通常的流程是自陷迫使控制流转移到内核、内核保存寄存器和其他状态以便于之后恢复之前的执行、内核执行对应的处理代码（例如，一个系统调用的实现或者设备驱动）、内核恢复保存的状态并从自陷返回、原来的代码从中断处恢复执行。

xv6在内核中处理所有的自陷，它们不会被分发到用户代码中。
对系统调用来说在内核中处理自陷是很自然的。
这么做对中断来说也是有意义的，因为隔离性要求只有内核才能使用设备，也因为内核是一种很方便地在多个进程间共享设备的机制。
对异常来说也同样有意义，因为xv6对所有来自用户空间的异常的处理方式都是杀掉引发异常的进程。

xv6的自陷处理按照四个阶段处理：RISC-V CPU执行的硬件行为，一些为内核中的C代码进行准备工作的汇编指令，一个决定要对自陷做什么的C函数，最后是相应的系统调用或者设备驱动的服务。
尽管三种自陷类型的共通之处表明内核可以在单一的代码段中处理这三种情况，但事实表明为以下三种情况分别编写不同的代码会更加方便：来自用户空间的自陷、来自内核空间的自陷、时钟中断。
处理自陷的内核代码（汇编或C）通常被称为\emph{handler}，第一个handler通常用汇编器（而不是C）编写，有时被称为\emph{向量(vector)}\footnote{todo！}。

\section{RISC-V自陷机制}
每个RISC-V CPU都有一组控制寄存器，内核通过写入这些寄存器来告诉CPU如何处理自陷，内核也可以通过读取这些寄存器来查明发生的自陷。
RISC-V的文档包含了完整的流程[3]。\texttt{riscv.h}\href{https://github.com/mit-pdos/xv6-riscv/blob/riscv//kernel/riscv.h#L1}{(kernel/riscv.h:1)}包含了xv6使用到的定义。
这里是最重要的寄存器的概述：
\begin{itemize}
    \item \texttt{stvec}：内核把自陷的handler的地址写入这个寄存器，RISC-V会跳转到\texttt{stvec}中的地址来处理一个自陷。
    \item \texttt{sepc}：当自陷发生时，RISC-V会把程序计数器保存到这里（因为\texttt{pc}即将被\texttt{stvec}中的值覆盖）。
    \texttt{sret}指令（用于从自陷返回）把\texttt{sepc}拷贝到\texttt{pc}。
    内核可以写入\texttt{sepc}来控制\texttt{sret}跳转的目标。
    \texttt{scause}：RISC-V把一个数字存储在里面，用来描述自陷的原因。
    \texttt{sscratch}：自陷的handler代码使用\texttt{sscratch}来避免在保存用户寄存器之前覆盖掉它们。
    \texttt{sstatus}：\texttt{sstatus}中的SIE位控制是否允许设备中断。
    如果内核清楚了SIE位，RISC-V将会推迟设备中断，直到内核设置SIE位。
    SPP位指示自陷是来自用户模式还是管理模式，并控制\texttt{sret}返回的模式。
\end{itemize}

上面的寄存器与在管理下处理的自陷有关，它们在用户模式下不能被读写。
还有一组类似的寄存器用于机器模式下处理的自陷，xv6只把它们用于时钟中断这个特殊的例子。

多核芯片上的每个CPU都有自己的寄存器，任何时刻都可能有不止一个CPU正在处理自陷。

当自陷发生时，RISC-V硬件为所有的自陷类型进行下列操作（时钟中断除外）：
\begin{enumerate}
    \item 如果自陷是一次设备中断，并且\texttt{sstatus}的SIE位被清除，那么不会进行下面的步骤。
    \item 清除\texttt{sstatus}中的SIE位来禁用中断。
    \item 把\texttt{pc}拷贝到\texttt{sepc}。
    \item 把当前的模式（用户或者管理模式）保存到\texttt{sstatus}的SPP位中。
    \item 设置\texttt{scause}来表明自陷的原因。
    \item 把模式设置为管理模式。
    \item 把\texttt{stvec}拷贝到\texttt{pc}。
    \item 开始在新\texttt{pc}处执行。
\end{enumerate}

注意CPU不会切换到内核页表，也不会切换到内核栈，也不会保存除了\texttt{pc}之外的任何寄存器。
内核软件必须自己完成这些任务。
CPU在自陷过程中只做最少的工作，其中一个原因是为了给软件提供灵活性，例如，有些操作系统在某些情况下会省略页表的切换以提高自陷的性能。

一个值得思考的问题是上面列出的步骤是否都可以省略以提高性能。
尽管有些情况下更简单的步骤就可以正常工作，但一般情况下很多步骤如果被省略都会很危险。
例如，假设CPU不切换程序计数器。
那么一个来自用户空间的自陷就可以切换到管理模式同时继续运行用户的指令。
这些用户指令可能会打破用户/内核的隔离，例如通过修改\texttt{satp}寄存器，让它指向一个允许所有物理内存访问的页表。
因此让CPU切换到一个内核指定的指令地址，即\texttt{stvec}是很重要的。

\section{用户空间的自陷}
xv6根据自陷是在执行内核还是用户代码时出现的进行不同的处理。
这一节介绍来自用户代码的自陷，\autoref{s4-5}描述了来自内核代码的自陷。

用户空间发生的中断可能是因为用户程序进行了系统调用（\texttt{ecall}指令），或者进行了非法操作，或者是设备中断。
处理来自用户空间的自陷的入口是\texttt{uservec}\href{https://github.com/mit-pdos/xv6-riscv/blob/riscv//kernel/trampoline.S#L21}{(kernel/trampoline.S:21)}，然后是\texttt{usertrap}\href{https://github.com/mit-pdos/xv6-riscv/blob/riscv//kernel/trap.c#L37}{(kernel/trap.c:37)}；返回时先是\texttt{usertrapret}\href{https://github.com/mit-pdos/xv6-riscv/blob/riscv//kernel/trap.c#L90}{(kernel/trap.c:90)}，然后是\texttt{userret}\href{https://github.com/mit-pdos/xv6-riscv/blob/riscv//kernel/trampoline.S#L101}{(kernel/trampoline.S:101)}。

在设计xv6的自陷处理时，一个主要的限制是RISC-V硬件在自陷时不会切换页表。
这意味着\texttt{stvec}中的自陷handler地址必须在用户页表中有一个有效的映射，因为自陷处理代码开始执行时的页表还是用户页表。
另外，xv6的自陷处理代码需要切换到内核的页表，为了能在切换后继续执行，内核的页表中也必须有\texttt{stvec}中存储的handler地址的有效映射。

xv6使用一个\emph{trampoline}页来满足这些需求。
trampoline页中包含了\texttt{uservec}，这是\texttt{stvec}指向的xv6的自陷处理代码。
trampoline页在每个进程的页表中被映射到\texttt{TRAMPOLINE}地址处，这个地址位于虚拟地址空间的顶部，这样它将位于程序自身用到的内存空间之上。
trampoline页也在内核的页表中被映射到了\texttt{TRAMPOLINE}地址。
如\autoref{f2-2}和\autoref{3-3}所示。
因为trampoline页被映射到了用户页表中，并且没有\texttt{PTE\_U}标记，所以自陷可以在管理模式下在那里开始执行。
同时因为trampoline页也被映射到了内核地址空间的同一地址处，自陷handler可以在切换到内核页表后继续执行。

\texttt{uservec}自陷handler的代码在\texttt{trampoline.S}\href{https://github.com/mit-pdos/xv6-riscv/blob/riscv//kernel/trampoline.S#L21}{(kernel/trampoline.S:21)}中。
当\texttt{uservec}开始执行时，所有32个寄存器包含的值都属于被中断的用户代码。
这32个值必须要保存到内存中，这样在返回用户空间之前可以恢复它们。
把值保存到内存中需要一个寄存器来存储目标地址，但在这个时候没有通用寄存器可以用！
幸运的是RISC-V以\texttt{sscratch}寄存器的形式提供了帮助。
\texttt{uservec}中开头的\texttt{csrw}指令寄存器把\texttt{a0}保存到\texttt{sscratch}中。
现在\texttt{uservec}就有了一个可以操作的寄存器（\texttt{a0}）。

\texttt{uservec}的下一个任务是保存32个用户寄存器。
内核为每个进程分配了一个内存页用来存储一个\texttt{trapframe}结构体，它有足够的空间存储32个用户寄存器\href{https://github.com/mit-pdos/xv6-riscv/blob/riscv//kernel/proc.h#L43}{(kernel/proc.h:43)}。
因为此时\texttt{satp}仍然指向用户页表，所以\texttt{uservec}需要trapframe被映射到用户地址空间。
xv6把每个进程的trapframe映射到那个进程的用户页表的虚拟地址\texttt{TRAPFRAME}处，\texttt{TRAPFRAME}正好在\texttt{TRAMPOLINE}下面。
进程的\texttt{p->trapframe}也指向trapframe，不过是指向它的物理地址，这样内核可以通过内核页表使用它。

\texttt{uservec}把地址\texttt{TRAPFRAME}加载到\texttt{a0}中，然后把所有用户寄存器保存在那里，包括用户的\texttt{a0}寄存器。

\texttt{trapframe}包含当前进程的内核栈的地址、当前CPU的hartid、\texttt{usertrap}函数的地址、内核页表的地址。
\texttt{uservec}检索这些值，然后把\texttt{satp}切换到内核的页表，最后调用\texttt{usertrap}。

\texttt{usertrap}的任务是判定自陷的原因、处理它、最后返回\href{https://github.com/mit-pdos/xv6-riscv/blob/riscv//kernel/trap.c#L37}{(kernel/trap.c:37)}。
它首先修改\texttt{stvec}，这样在内核中触发的自陷就会被\texttt{kernelvec}而不是\texttt{uservec}处理。
它还会保存\texttt{sepc}寄存器（用于保存用户程序的计数器），因为\texttt{usertrap}可能会调用\texttt{yield}来切换到另一个进程的内核线程，并且那个进程可能会返回用户空间，这个过程中它会修改\texttt{sepc}。
如果自陷是一个系统调用，那么\texttt{usertrap}调用\texttt{syscall}来处理它；如果是一个设备中断，则调用\texttt{devintr}；否则就是一个异常，内核会杀死出故障的进程。
系统调用的handler会把保存的用户程序计数器加上4，因为在系统调用的情况下程序计数器会指向\texttt{ecall}指令，而用户代码需要在下一条指令处恢复执行。
在退出过程中，\texttt{usertrap}检查进程是否已被killed，或是否应该让出CPU（如果这个自陷是计时器中断）。

返回到用户地址空间的第一步是调用\texttt{usertrapret}\href{https://github.com/mit-pdos/xv6-riscv/blob/riscv//kernel/trap.c#L90}{(kernel/trap.c:90)}。
这个函数设置RISC-V控制寄存器，为下一个用户空间的自陷做准备。
这涉及到把\texttt{stvec}设置为\texttt{uservec}，准备\texttt{uservec}依赖的trapframe字段，并把\texttt{sepc}设置为之前保存的用户程序计数器。
最后，\texttt{usertrapret}调用\texttt{userret}函数，这个函数在trampoline页里，因为\texttt{userret}中的汇编代码会切换页表。

\texttt{usertrapret}调用\texttt{userret}时会用\texttt{a0}传递一个指向进程的用户页表的指针\href{https://github.com/mit-pdos/xv6-riscv/blob/riscv//kernel/trampoline.S#L101}{(kernel/trampoline.S:101)}。
\texttt{userret}把\texttt{satp}设置为进城的用户页表。
回顾一下，用户页表映射了内核中的trampoline页和\texttt{TRAPFRAME}。
trampoline页被映射到了用户和内核页表中的同一虚拟地址处，这允许\texttt{userret}在修改\texttt{satp}之后还能继续执行。
从这个点开始，\texttt{userret}唯一可以使用的数据就是寄存器和trapframe的内容。
\texttt{userret}把\texttt{TRAPFRAME}地址加载进\texttt{a0}，通过\texttt{a0}恢复trapframe中保存的用户寄存器的内容，恢复保存的用户\texttt{a0}，然后执行\texttt{sret}来返回到用户空间。

\section{代码：调用系统调用}
\autoref{ch02}结束时提到\texttt{initcode.S}会调用\texttt{exec}\href{https://github.com/mit-pdos/xv6-riscv/blob/riscv//user/initcode.S#L11}{(user/initcode.S:11)}系统调用。
让我们看看用户调用是怎么逐渐到达内核中的\texttt{exec}系统调用实现的。

\texttt{initcode.S}把\texttt{exec}的参数放在寄存器\texttt{a0}和\texttt{a1}中，把系统调用号放在\texttt{a7}中。
系统调用号和\texttt{syscalls}数组中的条目匹配，这个数组是一个函数指针表\href{https://github.com/mit-pdos/xv6-riscv/blob/riscv//kernel/syscall.c#L107}{(kernel/syscall.c:107)}。
\texttt{ecall}指令陷入内核并逐步执行\texttt{uservec}、\texttt{usertrap}、\texttt{syscall}，这些我们上一节已经说过了。

\texttt{syscall}\href{https://github.com/mit-pdos/xv6-riscv/blob/riscv//kernel/syscall.c#L132}{(kernel/syscall.c:132)}从trapframe中存储的\texttt{a7}中获取获取系统调用号，并使用它索引\texttt{syscalls}。
对于第一个系统调用，\texttt{a7}中的值是\texttt{SYS\_exec}\href{https://github.com/mit-pdos/xv6-riscv/blob/riscv//kernel/syscall.h#L8}{(kernel/syscall.h:8)}，所以之后会调用\texttt{sys\_exec}函数作为系统调用的实现。

当\texttt{sys\_exec}返回时，\texttt{syscall}会把它的返回值记录在\texttt{p->trapframe->a0}中。
这将会导致最初对\texttt{exec()}的用户空间的调用也返回这个值，因为RISC-V中的C调用规范会把返回值存在\texttt{a0}中。
系统调用通常返回负值表示出错，0或正数表示成功。
如果系统调用号无效，\texttt{syscall}会打印出一个错误然后返回\texttt{-1}。

\section{代码：系统调用参数}

\section{来自内核空间的自陷}\label{s4-5}

\section{页面错误异常}\label{s4-6}
