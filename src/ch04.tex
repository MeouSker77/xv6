\chapter{自陷和系统调用}\label{ch04}

有三种事件会导致CPU暂停执行普通的指令，并强行跳转到处理这个事件的特殊代码处。
一种情况是系统调用，用户程序执行\texttt{ecall}指令要求内核为它提供服务。
另一种情况是\emph{异常(exception)}：一条指令（用户程序或内核中的）做了一些非法的事情，例如除以0或者使用了无效的虚拟地址。
第三种情况是设备\emph{中断(interrupt)}：一个设备可能会发送信号表示它需要关注，例如磁盘硬件完成了一个读或写请求。

这本书使用\emph{自陷(trap)}作为这三种情况的通用术语。
通常情况下，不管自陷时在执行什么代码，之后都需要恢复，并且这段代码不应该意识到这期间发生了别的事情。
也就是说，我们希望自陷是透明的，这对硬件中断来说尤其重要，被中断的代码通常不期望这些中断。
通常的流程是自陷迫使控制流转移到内核、内核保存寄存器和其他状态以便于之后恢复之前的执行、内核执行对应的处理代码（例如，一个系统调用的实现或者设备驱动）、内核恢复保存的状态并从自陷返回、原来的代码从中断处恢复执行。

xv6在内核中处理所有的自陷，它们不会被分发到用户代码中。
对系统调用来说在内核中处理自陷是很自然的。
这么做对中断来说也是有意义的，因为隔离性要求只有内核才能使用设备，也因为内核是一种很方便地在多个进程间共享设备的机制。
对异常来说也同样有意义，因为xv6对所有来自用户空间的异常的处理方式都是杀掉引发异常的进程。

xv6的自陷处理按照四个阶段处理：RISC-V CPU执行的硬件行为，一些为内核中的C代码进行准备工作的汇编指令，一个决定要对自陷做什么的C函数，最后是相应的系统调用或者设备驱动的服务。
尽管三种自陷类型的共通之处表明内核可以在单一的代码段中处理这三种情况，但事实表明为以下三种情况分别编写不同的代码会更加方便：来自用户空间的自陷、来自内核空间的自陷、时钟中断。
处理自陷的内核代码（汇编或C）通常被称为\emph{handler}，第一个handler通常用汇编器（而不是C）编写，有时被称为\emph{向量(vector)}\footnote{todo！}。

\section{RISC-V自陷机制}

\section{页面错误异常}\label{s4-6}
