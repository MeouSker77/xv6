\chapter{锁}\label{ch06}

包括xv6在内的大多数内核都交错执行多个活动。
交错执行的一个原因是多处理器硬件：有多个独立执行计算等等CPU的计算机，例如xv6的RISC-V。
这些CPU会共享物理RAM，xv6利用这种共享来维护所有CPU读写的数据结构。
这种共享导致了可能会有一个CPU正在读取一个数据结构，而同时还有另一个CPU也正在更新它，或者多个CPU同时更新同一个数据。
如果没有精心的设计，这种并行访问可能会返回错误的结果或者破坏数据结构。
即使在一个单处理器上，内核也可能在多个线程间切换CPU，导致它们的执行是交错的。
最后，设备中断处理程序可能和被中断的代码修改同一个数据，如果中断恰好在错误的时间发生就可能破坏数据。
单词\emph{并发(concurrency)}指多个指令流交错执行的情况，可能是因为多处理器并行、线程切换或者中断。

内核中充满了并发访问的数据。
例如，两个CPU可能会同时调用\texttt{kalloc}，因此它们会并发地从空闲列表的头部移除节点。
内核设计者更喜欢允许很多并发，因为这样可以通过并行提高性能和响应能力。
然而，内核设计者必须确保这种并发的正确性。
有很多种方法可以写出正确的代码，其中一些比另外一些更加容易理解。
致力于在并发中保持正确性的策略，以及支撑这些策略的概念，被称之为\emph{并发控制(concurrency control)}技术。

xv6根据具体情况使用了很多并发控制技术，还有可能使用更多。
这一章聚焦于一个被广泛使用的技术：\emph{锁(lock)}。
锁提供了相互排斥性，确保了某一个时间点只有一个CPU可以持有这个锁。
如果程序员把一个锁和一些共享数据联系起来，并且代码总是在使用数据的时候持有相关的锁，那么这个数据在任何时间点都只被一个CPU使用。
在这种情况下，我们说锁保护了这个数据。
尽管锁是非常容易理解的并发控制机制，但锁的弊端是它们可能会限制性能，因为它们把并发的操作串行化了。

本章的剩余部分将解释为什么xv6需要锁、xv6如何实现锁、以及如何使用它们。

\section{竞争}

\section{代码：锁}

\section{代码：使用锁}

\section{死锁和加锁顺序}

\section{可重入锁}

\section{锁和中断处理程序}\label{s6-6}
