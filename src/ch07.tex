\chapter{调度}\label{ch07}

任何操作系统都可能需要运行比处理器数量更多的进程，因此需要一个计划来在进程之间共享处理器。理想状态下这种共享对用户进程来说应该是透明的。一个通用的解决方案是通过在多个进程间\emph{多路复用(multiplex)}硬件处理器来给每个进程提供虚拟的处理器。这一章将解释xv6如何实现这种复用。

\section{多路复用}
xv6在两种情况下会把CPU从一个进程切换到另一个进程。
一个是，xv6的\texttt{sleep}和\texttt{wakeup}机制会在进程等待设备或管道I/O完成、等待子进程退出、在\texttt{sleep}系统调用中等待时切换进程。
另一个是，xv6会周期性的强制切换以应对长时间计算无需睡眠的进程。
这种多路复用创造出了每个进程都有单独的CPU的假象，类似于xv6使用内存分配器和硬件分页表来创造每个进程都有单独的内存的假象。

实现多路复用也面临一些挑战。
第一，如何从一个进程切换到另一个？
尽管上下文切换的思路很简单，但实现是xv6中最不透明的部分之一。
第二，如何以一种对用户透明的方式强制切换进程？
xv6使用了标准的计数，也就是用硬件时钟的中断来驱动上下文的切换。
第三，所有的CPU在一个共享的进程集合中切换，因此需要一种加锁的方案来避免竞争。
第四，一个进程的内存和其他资源必须在进程退出时释放，但这个过程并不能完全由进程自身来实现，例如它不能在使用中释放它自己的内核栈。
第五，多核机器的每个核心都必须记住它正在执行哪个进程，这样系统调用才能影响到正确的进程的内核状态。
最后，\texttt{sleep}和\texttt{wakeup}允许一个进程放弃CPU并等待被另一个进程或中断唤醒。
需要小心避免导致唤醒通知丢失的竞争。
xv6尝试尽可能简单地解决这些问题，但最终的代码仍然很棘手。

\section{代码：上下文切换}
